<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>SOUGEN Style Interactive</title>
    <style>
        /* 1. 스타일 정의 */
        body { 
            margin: 0; 
            overflow: hidden; /* 스크롤바 없애기 */
            background-color: #050505;
            font-family: 'Inter', sans-serif;
            color: white;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            width: 80%;
            max-width: 800px;
            transition: opacity 1.5s ease; /* 서서히 사라지는 효과 */
        }

        /* 사라질 때 붙일 클래스 */
        .content.hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 5rem;
            font-weight: 800;
            margin: 0;
            background: linear-gradient(to right, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            letter-spacing: -2px;
        }

        p {
            font-size: 1.2rem;
            color: #ccc;
            margin-top: 20px;
        }

        .glass-card {
            margin-top: 50px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            display: inline-block;
        }

        .btn {
            background: linear-gradient(90deg, #00ffff, #0088ff);
            border: none;
            padding: 15px 40px;
            color: black;
            font-weight: bold;
            font-size: 1rem;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="content">
        <h1>HINOMAD</h1>
        <p>WEB3 CREATIVE PLATFORM</p>
        
        <div class="glass-card">
            <h3>Connect to the Future</h3>
            <p style="font-size: 0.9rem; margin-bottom: 20px;">Experience the next generation of web interaction.</p>
            <button class="btn">ENTER APP</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. 씬 설정 ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002); // 깊이감 안개

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5; // 초기 카메라 위치

        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 2. 오브젝트 생성 ---
        
        // (1) 배경 입자 (Particles)
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 3000;
        const posArray = new Float32Array(particlesCount * 3);

        for(let i = 0; i < particlesCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 30; // 넓게 퍼트리기
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.02,
            color: 0x00ffff,
            transparent: true,
            opacity: 0.8
        });
        const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particlesMesh);

        // (2) 중앙 와이어프레임 구체
        const sphereGeo = new THREE.IcosahedronGeometry(1.5, 1);
        const sphereMat = new THREE.MeshBasicMaterial({ 
            color: 0xff00ff, 
            wireframe: true 
        });
        const sphere = new THREE.Mesh(sphereGeo, sphereMat);
        scene.add(sphere);

        // --- 3. 인터랙션 변수 설정 ---
        let mouseX = 0;
        let mouseY = 0;
        let isEntering = false; // 버튼 눌렀는지 체크하는 변수
        let speed = 0; // 빨려 들어가는 속도

        // 마우스 움직임 감지
        document.addEventListener('mousemove', (event) => {
            mouseX = event.clientX / window.innerWidth - 0.5;
            mouseY = event.clientY / window.innerHeight - 0.5;
        });

        // ★ 버튼 클릭 이벤트 리스너 ★
        const btn = document.querySelector('.btn');
        const contentDiv = document.querySelector('.content');

        btn.addEventListener('click', () => {
            isEntering = true; // 진입 시작 신호
            contentDiv.classList.add('hidden'); // 글자 숨기기 (CSS 클래스 추가)
        });

        // --- 4. 애니메이션 루프 ---
        const clock = new THREE.Clock();

        function animate() {
            const elapsedTime = clock.getElapsedTime();
            requestAnimationFrame(animate);

            // 오브젝트 기본 회전
            sphere.rotation.y += 0.005;
            sphere.rotation.x += 0.002;
            particlesMesh.rotation.y = elapsedTime * 0.05;

            // ★ 상태에 따른 카메라 움직임 분기 처리 ★
            if (isEntering) {
                // 1. 진입 모드일 때: 카메라가 앞으로 전진 (가속도 붙임)
                speed += 0.002; 
                camera.position.z -= (0.1 + speed); 
                sphere.rotation.z += 0.1; // 구체도 미친듯이 회전시킴

                // 2. 카메라가 충분히 들어가면 (z < -10) 뭔가 다른 일을 할 수도 있음
                // 예: window.location.href = "game.html"; 
                
            } else {
                // 3. 대기 모드일 때: 마우스 따라다니기 (Parallax)
                // 부드러운 움직임을 위해 보간(Lerp) 공식 사용
                camera.position.x += (mouseX * 2 - camera.position.x) * 0.05;
                camera.position.y += (-mouseY * 2 - camera.position.y) * 0.05;
                
                // 입자도 마우스 따라 기울어짐
                particlesMesh.rotation.x = mouseY * 0.5;
                particlesMesh.rotation.y += mouseX * 0.05;
            }

            camera.lookAt(scene.position);
            renderer.render(scene, camera);
        }

        animate();

        // 화면 크기 변경 대응
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>